# Enable profiling (uncomment to debug startup time)
# zmodload zsh/zprof

# Fix insecure directory permissions before Oh My Zsh loads
ZSH_DISABLE_COMPFIX="true"

# Path to Oh My Zsh installation
export ZSH="$HOME/.oh-my-zsh"

# Disable auto-setting terminal title
DISABLE_AUTO_TITLE="true"

# Performance optimizations
DISABLE_UNTRACKED_FILES_DIRTY="true"
COMPLETION_WAITING_DOTS="true"
ENABLE_CORRECTION="false"

# Disable spelling correction
unsetopt correct
unsetopt correct_all

# Plugins (load only what you need)
plugins=(
    git
    macos
    docker
    kubectl
    fzf
    fzf-tab
    zsh-autosuggestions
    zsh-syntax-highlighting
)

# Load Oh My Zsh
source $ZSH/oh-my-zsh.sh

# Initialize completions once (remove duplicate calls)
autoload -Uz compinit
# Optimize completion loading - only regenerate once per day
if [[ -n ${ZDOTDIR:-$HOME}/.zcompdump(#qNmh+24) ]]; then
    compinit
else
    compinit -C
fi

# Environment setup
# ==================

# Pyenv
export PYENV_ROOT="$HOME/.pyenv"
[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
command -v pyenv >/dev/null && eval "$(pyenv init -)"

# NVM (Node Version Manager)
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" --no-use  # --no-use for faster startup
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"

# Conda
__conda_setup="$('/opt/homebrew/Caskroom/miniconda/base/bin/conda' 'shell.zsh' 'hook' 2> /dev/null)"
if [ $? -eq 0 ]; then
    eval "$__conda_setup"
else
    if [ -f "/opt/homebrew/Caskroom/miniconda/base/etc/profile.d/conda.sh" ]; then
        . "/opt/homebrew/Caskroom/miniconda/base/etc/profile.d/conda.sh"
    else
        export PATH="/opt/homebrew/Caskroom/miniconda/base/bin:$PATH"
    fi
fi
unset __conda_setup

# Path additions
export PATH="/opt/homebrew/opt/postgresql@15/bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"
export PATH="/opt/homebrew/opt/trash/bin:$PATH"
export PATH="/opt/homebrew/opt/llvm/bin:$PATH"

# Clang-tidy
export CLANG_TIDY_DIR=~/tools/clang-tidy
export PATH="$CLANG_TIDY_DIR/bin:$CLANG_TIDY_DIR:$PATH"
export LD_LIBRARY_PATH="$CLANG_TIDY_DIR/lib:$LD_LIBRARY_PATH"

# FZF-tab configuration
zstyle ':completion:*:descriptions' format '[%d]'
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
zstyle ':completion:*' menu no
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'lsd -1 --color=always $realpath 2>/dev/null || ls -la'
zstyle ':fzf-tab:*' fzf-flags --color=fg:1,fg+:2 --bind=tab:accept
zstyle ':fzf-tab:*' switch-group '<' '>'

# Autosuggestions configuration
ZSH_AUTOSUGGEST_STRATEGY=(history completion)
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=#999'

# Colors
export CLICOLOR=1
export LSCOLORS=ExFxBxDxCxegedabagacad

# Functions
# ==================

mktouch() {
    if [ $# -eq 0 ]; then
        echo "Usage: mktouch <file>"
        return 1
    fi
    
    local file="$1"
    mkdir -p "$(dirname "$file")" && touch "$file"
}

# Aliases
# ==================

# Editor
alias v="vi"
alias nv="nvim"
alias vf='nvim $(fzf)'

# File operations
alias touch="mktouch"
alias ll="ls -lah"
alias ls="lsd"
alias cat="bat"
alias rm="echo Use 'trash', or the full path i.e. '/bin/rm'"

# Navigation
alias ..="cd .."
alias ...="cd ../.."
alias ~="cd ~"
alias f="fzf"

# Git
alias gs="git status"
alias gc="git commit"
alias gps="git push"
alias gpl="git pull"
alias lg="lazygit"

gdc() {
  local main_branch
  
  # Debug: Show current branch
  echo "Current branch: $(git branch --show-current)"
  
  # Find main branch
  if git show-ref --quiet refs/heads/main; then
    main_branch="main"
  elif git show-ref --quiet refs/heads/master; then
    main_branch="master"
  elif git show-ref --quiet refs/heads/development; then
    main_branch="development"
  else
    echo "Main branch not found (main, master, or development)"
    return 1
  fi
  
  echo "Main branch detected: $main_branch"
  
  # Debug: Check if there are any differences
  local diff_output=$(git diff "$main_branch")
  
  if [ -z "$diff_output" ]; then
    echo "No differences found between current branch and $main_branch"
    return 0
  fi
  
  # Debug: Show diff size
  echo "Diff size: $(echo "$diff_output" | wc -c) characters"
  
  # Try to copy to clipboard
  echo "$diff_output" | pbcopy
  
  # Verify clipboard content
  local clipboard_size=$(pbpaste | wc -c)
  echo "Clipboard size after copy: $clipboard_size characters"
  
  if [ "$clipboard_size" -gt 0 ]; then
    echo "✓ Diff from $main_branch copied to clipboard."
  else
    echo "✗ Failed to copy diff to clipboard."
  fi
}

c2p-micro() {
    local temp_file=$(mktemp)
    code2prompt --hidden . \
      --exclude="**/test/**" \
      --exclude="**/tests/**" \
      --exclude="**/__pycache__/**" \
      --exclude="**/*.pyc" \
      --exclude="**/.pytest_cache/**" \
      --exclude="**/.coverage" \
      --exclude="**/htmlcov/**" \
      --exclude="**/.mypy_cache/**" \
      --exclude="**/.ruff_cache/**" \
      --exclude="**/dist/**" \
      --exclude="**/build/**" \
      --exclude="**/*.egg-info/**" \
      --exclude="**/.venv/**" \
      --exclude="**/venv/**" \
      --exclude="**/env/**" \
      --exclude="**/.env.*" \
      --exclude="**/alembic/versions/**" \
      --exclude="**/*_pb2.py" \
      --exclude="**/*_pb2_grpc.py" \
      --exclude="**/terraform/**" \
      --exclude="**/.terraform/**" \
      --exclude="**/k8s/**" \
      --exclude="**/helm/**" \
      --exclude="**/docs/**" \
      --exclude="**/*.md" \
      --include="README.md" \
      --include="**/requirements*.txt" \
      --include="**/pyproject.toml" \
      --include="**/*.yml" \
      --include="**/*.yaml" \
      --output-file="$temp_file"
    
    cat "$temp_file"
    trash "$temp_file"
}


compress_repo() {
    local output_file="${1:-compressed_repo.txt}"
    local aggressive="${2:-false}"
    
    echo "🔍 Analyzing repository structure..."
    
    # Get basic stats
    local file_count=$(find . -name "*.py" -type f | wc -l)
    local line_count=$(find . -name "*.py" -type f -exec cat {} \; | wc -l)
    
    echo "📊 Found $file_count Python files with $line_count total lines"
    
    # Create structure summary
    echo "=== REPOSITORY STRUCTURE ===" > "$output_file"
    tree -I '__pycache__|*.pyc|.git|.pytest_cache|venv|.venv|node_modules' \
         -P '*.py|*.yml|*.yaml|*.toml|*.txt|*.json' \
         --dirsfirst -L 3 >> "$output_file"
    
    echo -e "\n\n=== KEY CONFIGURATIONS ===" >> "$output_file"
    
    # Include key config files
    for config in "pyproject.toml" "requirements.txt" "requirements-*.txt" "Dockerfile" ".dockerignore"; do
        if [ -f "$config" ]; then
            echo -e "\n--- $config ---" >> "$output_file"
            cat "$config" >> "$output_file"
        fi
    done
    
    # Include important YAML configs (but compressed)
    echo -e "\n\n=== SERVICE DEFINITIONS ===" >> "$output_file"
    find . -name "*.yml" -o -name "*.yaml" | grep -E "(docker-compose|service|config)" | while read -r yaml; do
        echo -e "\n--- $yaml ---" >> "$output_file"
        # Remove comments and empty lines from YAML
        sed '/^\s*#/d; /^\s*$/d' "$yaml" >> "$output_file"
    done
    
    echo -e "\n\n=== SOURCE CODE ===" >> "$output_file"
    
    # Use code2prompt with compression
    if [ "$aggressive" = "true" ]; then
        echo "🗜️  Using aggressive compression..."
        c2p-micro | python3 compress_microservice.py >> "$output_file"
    else
        c2p-micro >> "$output_file"
    fi
    
    # Final stats
    local final_size=$(wc -c < "$output_file")
    local final_lines=$(wc -l < "$output_file")
    local token_estimate=$((final_size / 4))
    
    echo "✅ Compression complete!"
    echo "📄 Output: $output_file"
    echo "📏 Size: $(numfmt --to=iec-i --suffix=B $final_size) ($final_lines lines)"
    echo "🎯 Estimated tokens: ~$(numfmt --to=si $token_estimate)"
    
    # Copy to clipboard if available
    if command -v pbcopy &> /dev/null; then
        cat "$output_file" | pbcopy
        echo "📋 Copied to clipboard!"
    elif command -v xclip &> /dev/null; then
        cat "$output_file" | xclip -selection clipboard
        echo "📋 Copied to clipboard!"
    fi
}

# Alias for quick compression
alias c2p-compress='compress_repo compressed_$(basename $(pwd)).txt false'
alias c2p-aggressive='compress_repo compressed_$(basename $(pwd)).txt true'


# Docker
alias dk="docker"
alias dkc="docker-compose"

# AWS Vault
alias ave="aws-vault exec"
alias avl="aws-vault login"

# Python
alias python="python3"
alias pip="pip3"

# Config files
alias zshconfig="nv ~/.zshrc"
alias gitconfig="nv ~/.gitconfig"
alias awsconfig="nv ~/.aws/config"

# System
alias update="brew update && brew upgrade"
alias c="clear"
alias ff="fastfetch"
alias cr="cursor"
alias brewfile="~/.local/share/chezmoi/scripts/update_brewfile.sh"

# code2prompt
alias c2p='code2prompt --hidden . --exclude="**/test/**" --exclude="**/tests/**"'
alias c2pt="code2prompt --hidden ."

# Poetry
alias pp="poetry run poe all"
alias pu="poetry run poe test-unit"
alias pi="poetry run poe test-integration"
alias pt="poetry run poe typecheck"

#Terraform
alias ti="terraform init"
alias tp="terraform plan"
alias ta="terraform apply"

# Initialize tools (at the end for faster startup)
# ==================

# Zoxide (better cd)
command -v zoxide >/dev/null && eval "$(zoxide init zsh)"

# Starship prompt - MUST come before tmux launch
command -v starship >/dev/null && eval "$(starship init zsh)"

# Tmux auto-launch (MUST BE LAST!)
# ==================
# Launch tmux automatically if:
# - tmux is installed
# - we're in an interactive shell
# - we're not already in tmux
# - we're not in VS Code terminal
# - we're in a SSH session (optional - uncomment the SSH check if desired)

if command -v tmux &> /dev/null && \
   [ -n "$PS1" ] && \
   [[ ! "$TERM" =~ screen ]] && \
   [[ ! "$TERM" =~ tmux ]] && \
   [ -z "$TMUX" ] && \
   [ "$TERM_PROGRAM" != "vscode" ]; then
   # && [ -n "$SSH_CLIENT" ] || [ -n "$SSH_TTY" ]; then  # Uncomment for SSH only
   
   # Create a default session if none exists
   tmux has-session -t main 2>/dev/null || tmux new-session -d -s main
   
   # Attach to the main session
   tmux attach-session -t main
fi

# Profiling (uncomment to see startup time breakdown)
# zprofexport KALEIDOSCOPE_DIR=/Users/milesphillips/git/Kaleidoscope
export PATH="/opt/homebrew/opt/mysql-client/bin:$PATH"

# Added by Windsurf
export PATH="/Users/miles.phillips/.codeium/windsurf/bin:$PATH"
